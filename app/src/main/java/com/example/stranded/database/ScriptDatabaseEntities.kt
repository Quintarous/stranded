package com.example.stranded.database

import androidx.room.Entity
import androidx.room.PrimaryKey

/**
 * Database tables.
 */

/**
 * This table contains every ScriptLine object for the entire app.
 *
 * id: id number generated by room
 *
 * sequence: the sequence this ScriptLine is a part of
 *
 * type: ScriptLines need to specify whether they want to be displayed in the console (top left box
 * in the ui) or in the regular chatRecycler. So type will equal either "console" or "script" to
 * specify this.
 *
 * line: The actual text of the ScriptLine
 *
 * next: The number of the next line or Set to be displayed. When referring to a line it is the
 * index of the line + 1, and when referring to a Set it is the set.number property.
 *
 * nextType: Specifies whether the integer in the ScriptLine.next property is referring to
 * another ScriptLine or a prompt Set object. (Will be either "script" or "prompt")
 *
 * -------------------------------------------TLDR------------------------------------------
 *
 * TLDR EXPLANATION: There is no master narrative document that determines the order lines should
 * be displayed. Instead every individual ScriptLine/PromptLine specifies which line or Set that
 * should go next. For example
 *
 * line1.next = 2
 * line1.nextType = "script"
 *
 * This ScriptLine is saying "hey! display line number 2 next! Also, it's a ScriptLine!
 * The ViewModel will look at that and display the second line in sequence.lines which is
 * sequence.lines[1].
 *
 * line2.next = 4
 * line2.next = "prompt"
 *
 * Now line2 is saying "hey! display Set number 4 from this sequence next! The ViewModel will look at
 * this, then iterate through sequence.sets looking for one that has a set.number property of 4.
 * Then displays that set. (Remember a Set is just a list of PromptLines with a number assigned to it).
 *
 * NOTE: So ScriptLine.next goes off of a ScriptLines index + 1 as opposed to just the
 * id of that unique ScriptLine. This was done because I had to manually create
 * the entire database one entry at a time and being able to reference lines
 * by count ie: line 1, line 69, line 72 etc... Was WAY easier than looking
 * up that lines individual id that room assigned to it.
 */
@Entity
data class ScriptLine constructor(
    @PrimaryKey(autoGenerate = true)
    val id: Int = 0,
    val sequence: Int,
    val type: String,
    val line: String,
    val next: Int,
    val nextType: String = "script"
)


/**
 * This table contains every PromptLine object for the entire app.
 *
 * PromptLine is more or less the same as ScriptLine except they don't have a "type" property
 * because they are always displayed in the chatRecycler. Instead they have a "set" property,
 * which determines which Set any given line belongs to.
 */
@Entity
data class PromptLine constructor(
    @PrimaryKey(autoGenerate = true)
    val id: Int = 0,
    val sequence: Int,
    val set: Int,
    val line: String,
    val next: Int,
    val nextType: String = "script"
)


/**
 * This table contains every Trigger object for the entire app.
 *
 * Triggers (as the name implies) are objects that hold all the information to play either a sound
 * effect or an animation.
 *
 * id: id number generated by room
 *
 * sequence: Specifies which sequence this Trigger belongs to
 *
 * triggerId: The index + 1 of the ScriptLine or set.number of the Set this trigger is fired on.
 *
 * triggerType: Specifies whether triggerId is referring to a ScriptLine or prompt Set.
 * (Can be either "script" or "prompt"
 *
 * resourceType: The type of resource this trigger plays. (Either "sound" or "animation")
 *
 * resourceId: A string identifying the individual resource (sound or animation) to be played
 *
 * oneAndDone: Determines whether this trigger is meant to interrupt a previously looping
 * sound/animation, play once, and then go back to the original loop.
 *
 * NOTE: The string in resourceId was originally just the literal resource id number of a sound
 * or animation. (IE: R.drawable.g_up). But those change every time the app is started so I had to
 * change it to a string that just names the sound/animation and then have getResourceId() take
 * that string and translate it into a valid reference to the sound/animation.
 */
@Entity
data class Trigger constructor(
    @PrimaryKey(autoGenerate = true)
    val id: Int = 0,
    val sequence: Int,
    val triggerId: Int,
    val triggerType: String,
    val resourceType: String,
    val resourceId: String?,
    val loop: Boolean = false,
    val oneAndDone: Boolean = false
)


/**
 * This db table will only ever have one item in it and it's the users "save game" for lack of a
 * better term.
 *
 * id: id number of the UserSave (shouldn't come into play)
 *
 * isPowered: If is powered = false then the user will be unable to progress past the NoPowerFragment
 *
 * Stranded has wait periods in between narrative sequences where the user is waiting
 * for a notification to be able to play through the next part of the story. After completing a
 * sequence a notification is scheduled and when it fires isPowered is set to true.
 *
 * letterDuration: The number of milliseconds in between each character appearing in CustomTextViews
 * This is a customisation option so the user can have faster or slower animations if they want.
 *
 * sequence: Refers to which sequence the user is currently on
 *
 * line: Refers to which line the user is currently on (will be zero if the sequence hasn't been
 * started yet!)
 *
 * lineType: Can be ("script" "prompt" or "response"). It indicates what the "line" property is
 * referencing. When it's "script" line = scriptLine.id (NOT the index + 1). When it's "prompt"
 * line = a set.number. And finally when it's "response" line = a set.number but the user picked
 * an option so display that result.
 *
 * demoMode: Whether the user is in demo mode or not. Demo mode cancels notifications and just gives
 * the user a button in the NoPowerFragment to skip the wait and play the next sequence immediately.
 */
@Entity
data class UserSave constructor(
    @PrimaryKey
    val id: Int,
    var isPowered: Boolean,
    var letterDuration: Int = 70,
    var sequence: Int,
    var line: Int,
    var lineType: String = "script",
    var demoMode: Boolean = false
)


/**
 * The PromptResult db table is just a list of integers. As a user plays through a sequence and
 * makes dialogue choices the index (within it's Set) of the PromptLine they chose is recorded in
 * here. So when they leave and come back restoreSave() can refer to this table and see what
 * options the user chose and recreate them.
 *
 * This table is cleared at the end of every sequence to make way for the next one.
 */
@Entity
data class PromptResult constructor(
    @PrimaryKey(autoGenerate = true)
    val id: Int,
    val result: Int
)